<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Spine — Graph Visualizer</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<style>
:root {
  --bg: #0f1117;
  --surface: #1a1d27;
  --surface2: #242836;
  --border: #2e3345;
  --text: #e1e4ed;
  --text2: #8b90a0;
  --accent: #6c7bff;
  --accent2: #4a56d6;
  --green: #34d399;
  --red: #f87171;
  --radius: 8px;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  background: var(--bg);
  color: var(--text);
  overflow: hidden;
  height: 100vh;
  display: flex;
}

/* Sidebar */
#sidebar {
  width: 280px;
  min-width: 280px;
  background: var(--surface);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow-y: auto;
}

#sidebar h1 {
  font-size: 18px;
  padding: 16px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 600;
  letter-spacing: -0.3px;
}

#sidebar h1 span { color: var(--accent); }

.section {
  padding: 12px 16px;
  border-bottom: 1px solid var(--border);
}

.section-title {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.8px;
  color: var(--text2);
  margin-bottom: 10px;
}

.row {
  display: flex;
  gap: 6px;
  margin-bottom: 6px;
}

input, select {
  background: var(--surface2);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 6px 10px;
  border-radius: var(--radius);
  font-size: 13px;
  outline: none;
  flex: 1;
  min-width: 0;
}

input:focus, select:focus {
  border-color: var(--accent);
}

input::placeholder { color: var(--text2); }

button {
  background: var(--surface2);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 6px 12px;
  border-radius: var(--radius);
  font-size: 13px;
  cursor: pointer;
  white-space: nowrap;
  transition: all 0.15s;
}

button:hover {
  background: var(--border);
  border-color: var(--accent);
}

button.primary {
  background: var(--accent);
  border-color: var(--accent);
  color: #fff;
  font-weight: 500;
}

button.primary:hover {
  background: var(--accent2);
}

button.danger {
  color: var(--red);
}

button.danger:hover {
  background: rgba(248, 113, 113, 0.1);
  border-color: var(--red);
}

.full-width { width: 100%; }
.btn-sm { font-size: 11px; padding: 2px 8px; }

.toggle-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
}

.toggle-row label {
  font-size: 13px;
  color: var(--text2);
}

.toggle {
  position: relative;
  width: 40px;
  height: 22px;
  cursor: pointer;
}

.toggle input { display: none; }

.toggle .slider {
  position: absolute;
  inset: 0;
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 11px;
  transition: 0.2s;
}

.toggle .slider::before {
  content: '';
  position: absolute;
  width: 16px;
  height: 16px;
  left: 2px;
  top: 2px;
  background: var(--text2);
  border-radius: 50%;
  transition: 0.2s;
}

.toggle input:checked + .slider {
  background: var(--accent);
  border-color: var(--accent);
}

.toggle input:checked + .slider::before {
  transform: translateX(18px);
  background: #fff;
}

.algo-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 4px;
}

.algo-grid button {
  font-size: 12px;
  padding: 6px 4px;
  text-align: center;
}

/* Template description */
#template-desc {
  font-size: 12px;
  color: var(--text2);
  margin: 6px 0;
  min-height: 18px;
  line-height: 1.4;
}

/* Result panel */
#result-panel {
  display: none;
  padding: 10px 16px;
  border-bottom: 1px solid var(--border);
}

#result-panel.visible { display: block; }

#result-panel .result-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 6px;
}

#result-panel .result-title {
  font-size: 12px;
  font-weight: 600;
  color: var(--accent);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

#result-content {
  font-size: 12px;
  color: var(--text2);
  line-height: 1.6;
  word-break: break-word;
}

#result-content .highlight { color: var(--green); font-weight: 500; }
#result-content .error { color: var(--red); }

/* Info bar */
#info {
  padding: 12px 16px;
  margin-top: auto;
  border-top: 1px solid var(--border);
  font-size: 11px;
  color: var(--text2);
  line-height: 1.6;
}

#info kbd {
  background: var(--surface2);
  border: 1px solid var(--border);
  padding: 1px 5px;
  border-radius: 3px;
  font-size: 10px;
  font-family: inherit;
}

/* Canvas area */
#canvas-wrap {
  flex: 1;
  position: relative;
  overflow: hidden;
}

canvas {
  display: block;
  width: 100%;
  height: 100%;
}

/* Tooltip */
#tooltip {
  display: none;
  position: absolute;
  background: var(--surface);
  border: 1px solid var(--border);
  padding: 8px 12px;
  border-radius: var(--radius);
  font-size: 12px;
  pointer-events: none;
  z-index: 10;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  max-width: 220px;
}

#tooltip .tt-id { color: var(--accent); font-weight: 600; }
#tooltip .tt-detail { color: var(--text2); margin-top: 2px; }

/* Mode indicator */
#mode-indicator {
  position: absolute;
  top: 12px;
  left: 12px;
  background: var(--surface);
  border: 1px solid var(--border);
  padding: 6px 14px;
  border-radius: var(--radius);
  font-size: 12px;
  font-weight: 500;
  pointer-events: none;
  z-index: 5;
  opacity: 0;
  transition: opacity 0.2s;
}

#mode-indicator.visible { opacity: 1; }

/* Task progress bar */
.progress-bar {
  height: 6px;
  background: var(--surface2);
  border-radius: 3px;
  overflow: hidden;
  margin: 8px 0 6px;
}

.progress-fill {
  height: 100%;
  width: 0;
  background: var(--green);
  border-radius: 3px;
  transition: width 0.3s;
}

.progress-stats {
  font-size: 12px;
  color: var(--text2);
  margin-bottom: 6px;
}

.progress-stats .done-count { color: var(--green); font-weight: 600; }

.status-counts {
  display: flex;
  flex-wrap: wrap;
  gap: 4px 10px;
  font-size: 11px;
  color: var(--text2);
  margin-bottom: 8px;
}

.status-counts span {
  display: flex;
  align-items: center;
  gap: 4px;
}

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  display: inline-block;
}

/* Task section */
#task-section { display: none; }
#task-section.visible { display: block; }

#task-node-controls { display: none; margin-top: 8px; }
#task-node-controls.visible { display: block; }

.task-selected-label { font-size: 12px; color: var(--text2); margin-bottom: 4px; }
#task-node-label { color: var(--text); font-weight: 500; }
#reset-all-btn { margin-top: 8px; }

/* Status legend overlay */
#status-legend {
  display: none;
  position: absolute;
  top: 12px;
  right: 12px;
  background: rgba(26, 29, 39, 0.9);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 8px 12px;
  font-size: 11px;
  z-index: 5;
  pointer-events: none;
}

#status-legend.visible { display: block; }

#status-legend .legend-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin: 3px 0;
  color: var(--text2);
}

#status-legend .legend-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  border: 2px solid;
}

/* ---- Metadata section ---- */
#meta-section { display: none; }

.meta-target-label {
  font-size: 12px;
  color: var(--text2);
  margin-bottom: 8px;
}

.meta-target-label strong {
  color: var(--text);
  font-weight: 500;
}

.meta-entry {
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px 10px;
  margin-bottom: 4px;
}

.meta-entry-header {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 3px;
}

.meta-key {
  font-weight: 600;
  font-size: 12px;
  color: var(--accent);
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.meta-type {
  font-size: 10px;
  padding: 1px 5px;
  border-radius: 3px;
  background: var(--border);
  color: var(--text2);
  font-family: 'SF Mono', 'Fira Code', monospace;
  flex-shrink: 0;
}

.meta-del-btn {
  background: none;
  border: none;
  color: var(--text2);
  cursor: pointer;
  font-size: 14px;
  padding: 0 2px;
  line-height: 1;
  flex-shrink: 0;
}

.meta-del-btn:hover {
  color: var(--red);
  background: none;
  border: none;
}

.meta-value {
  font-size: 12px;
  color: var(--text2);
  word-break: break-all;
  font-family: 'SF Mono', 'Fira Code', monospace;
  line-height: 1.4;
}

.meta-empty {
  font-size: 12px;
  color: var(--text2);
  padding: 8px 0;
  text-align: center;
}

.meta-pagination {
  display: none;
  align-items: center;
  justify-content: center;
  gap: 8px;
  margin: 6px 0;
  font-size: 12px;
  color: var(--text2);
}

.meta-pagination button {
  font-size: 11px;
  padding: 2px 8px;
}

.meta-pagination button:disabled {
  opacity: 0.4;
  cursor: default;
}

.meta-add-title {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.6px;
  color: var(--text2);
  margin: 8px 0 6px;
}

.meta-entry { cursor: pointer; transition: border-color 0.15s; }
.meta-entry:hover { border-color: var(--accent); }

/* ---- Fullscreen Metadata Viewer ---- */
#meta-fullscreen {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 200;
  background: rgba(0,0,0,0.65);
  align-items: center;
  justify-content: center;
}
#meta-fullscreen.visible { display: flex; }

.meta-fs-panel {
  width: 90vw;
  height: 90vh;
  background: #12141c;
  border: 1px solid var(--border);
  border-radius: 10px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
}

.meta-fs-header {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 16px;
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

.meta-fs-key {
  font-weight: 600;
  font-size: 14px;
  color: var(--text);
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.meta-fs-type {
  font-size: 11px;
  padding: 2px 8px;
  border-radius: 4px;
  background: var(--border);
  color: var(--text2);
  font-family: 'SF Mono', 'Fira Code', monospace;
}

.meta-fs-close {
  background: none;
  border: none;
  color: var(--text2);
  font-size: 22px;
  cursor: pointer;
  padding: 0 4px;
  line-height: 1;
}
.meta-fs-close:hover { color: var(--red); background: none; border: none; }

.meta-fs-body {
  flex: 1;
  overflow: auto;
  padding: 0;
}

.meta-fs-body pre {
  margin: 0;
  padding: 16px;
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
  font-size: 13px;
  line-height: 1.6;
  counter-reset: line;
}

.meta-fs-body .line-row {
  display: block;
}

.meta-fs-body .line-num {
  display: inline-block;
  width: 48px;
  text-align: right;
  padding-right: 16px;
  color: var(--text2);
  opacity: 0.4;
  user-select: none;
  font-size: 12px;
}

.meta-fs-body .line-content {
  white-space: pre;
}

/* Syntax highlight classes */
.syn-key { color: var(--accent); }
.syn-str { color: var(--green); }
.syn-num { color: var(--text); }
.syn-bool, .syn-null { color: var(--red); }

/* Override highlight.js background to match our theme */
.meta-fs-body .hljs {
  background: transparent;
  padding: 0;
}

/* Extension filter chips */
.ext-chip-container {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  margin: 6px 0;
  min-height: 0;
}

.ext-chip {
  display: inline-flex;
  align-items: center;
  gap: 3px;
  background: var(--accent2);
  color: #fff;
  font-size: 11px;
  padding: 2px 6px 2px 8px;
  border-radius: 12px;
  white-space: nowrap;
}

.ext-chip-x {
  cursor: pointer;
  font-size: 13px;
  line-height: 1;
  opacity: 0.7;
  padding: 0 2px;
}

.ext-chip-x:hover { opacity: 1; }

.ext-presets {
  display: flex;
  gap: 4px;
  margin: 4px 0;
  flex-wrap: wrap;
}

.ext-presets button {
  font-size: 10px;
  padding: 2px 8px;
  border-radius: 10px;
}

/* Mobile: hamburger toggle (hidden on desktop) */
#menu-toggle {
  display: none;
  position: absolute;
  top: 12px;
  left: 12px;
  z-index: 20;
  width: 42px;
  height: 42px;
  font-size: 22px;
  line-height: 42px;
  text-align: center;
  padding: 0;
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--text);
  border-radius: var(--radius);
  cursor: pointer;
}

/* Mobile: sidebar overlay backdrop (hidden on desktop) */
#sidebar-overlay {
  display: none;
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.5);
  z-index: 9;
}

.mobile-hints { display: none; }

/* ---- Mobile responsive ---- */
@media (max-width: 767px) {
  #menu-toggle { display: block; }

  #sidebar {
    position: fixed;
    top: 0;
    left: 0;
    height: 100vh;
    transform: translateX(-100%);
    transition: transform 0.25s ease;
    z-index: 100;
  }

  #sidebar.open {
    transform: translateX(0);
    box-shadow: 4px 0 24px rgba(0,0,0,0.5);
  }

  #sidebar-overlay.visible { display: block; z-index: 10; }

  #mode-indicator { left: 60px; }

  #sidebar input,
  #sidebar select,
  #sidebar button {
    padding: 10px 12px;
    font-size: 14px;
  }

  #sidebar .algo-grid button {
    padding: 10px 4px;
    font-size: 13px;
  }

  .desktop-hints { display: none; }
  .mobile-hints { display: inline; }
}
</style>
</head>
<body>

<div id="sidebar">
  <h1><span>&#9670;</span> Spine Visualizer</h1>

  <div class="section">
    <div class="section-title">Graph Mode</div>
    <div class="toggle-row">
      <label>Directed</label>
      <label class="toggle">
        <input type="checkbox" id="directed-toggle" checked>
        <span class="slider"></span>
      </label>
    </div>
    <button class="danger full-width" id="clear-graph-btn">Clear Graph</button>
  </div>

  <div class="section">
    <div class="section-title">Import / Export</div>
    <div class="row">
      <button class="primary" id="export-btn" style="flex:1">Export JSON</button>
      <button id="import-btn" style="flex:1">Import JSON</button>
    </div>
    <input type="file" id="import-file" accept=".json" style="display:none">
  </div>

  <div class="section">
    <div class="section-title">Directory Upload</div>
    <button class="primary full-width" id="dir-upload-btn">Upload Directory</button>
    <label style="font-size:12px;color:var(--text2);margin-top:6px;display:flex;align-items:center;gap:6px">
      <input type="checkbox" id="dir-include-content" checked> Include file contents
    </label>
    <div style="margin-top:8px">
      <div style="font-size:11px;color:var(--text2);margin-bottom:4px">Filter by extension</div>
      <div class="row">
        <input id="ext-input" placeholder=".go, .py, .js ...">
        <button class="btn-sm" id="ext-add-btn">Add</button>
      </div>
      <div class="ext-presets">
        <button data-preset="code">Code</button>
        <button data-preset="config">Config</button>
        <button data-preset="docs">Docs</button>
        <button id="ext-clear-btn">Clear</button>
      </div>
      <div class="ext-chip-container" id="ext-chips"></div>
    </div>
    <div id="dir-progress" style="display:none;margin-top:8px">
      <div class="progress-bar"><div class="progress-fill" id="dir-progress-fill"></div></div>
      <div style="font-size:11px;color:var(--text2)" id="dir-progress-text">Reading files...</div>
    </div>
    <input type="file" id="dir-upload-file" webkitdirectory style="display:none">
  </div>

  <div class="section">
    <div class="section-title">Templates</div>
    <select id="template-select">
      <option value="">Load a template...</option>
    </select>
    <div id="template-desc"></div>
    <button class="primary full-width" id="load-template-btn" disabled>Load Template</button>
  </div>

  <div class="section">
    <div class="section-title">Add Node</div>
    <div class="row">
      <input id="node-id" placeholder="Node ID">
      <input id="node-label" placeholder="Label (opt)">
    </div>
    <button class="primary full-width" id="add-node-btn">Add Node</button>
  </div>

  <div class="section">
    <div class="section-title">Add Edge</div>
    <div class="row">
      <input id="edge-from" placeholder="From">
      <input id="edge-to" placeholder="To">
    </div>
    <div class="row">
      <input id="edge-weight" placeholder="Weight" type="number" value="1" step="any">
    </div>
    <button class="primary full-width" id="add-edge-btn">Add Edge</button>
  </div>

  <div class="section" id="task-section">
    <div class="section-title">Task Status</div>
    <div class="progress-stats"><span class="done-count" id="task-done-count">0/0</span> done — <span id="task-pct">0</span>%</div>
    <div class="progress-bar"><div class="progress-fill" id="task-progress"></div></div>
    <div class="status-counts" id="task-status-counts"></div>
    <div id="task-node-controls">
      <div class="task-selected-label">Selected: <span id="task-node-label"></span></div>
      <div class="row">
        <select id="task-status-select">
          <option value="pending">Pending</option>
          <option value="ready">Ready</option>
          <option value="running">Running</option>
          <option value="done">Done</option>
          <option value="failed">Failed</option>
          <option value="skipped">Skipped</option>
        </select>
        <button class="primary" id="update-status-btn">Update</button>
      </div>
    </div>
    <button class="danger full-width" id="reset-all-btn">Reset All</button>
  </div>

  <div class="section" id="meta-section">
    <div class="section-title">Metadata</div>
    <div class="meta-target-label" id="meta-target-label"></div>
    <div id="meta-entries"></div>
    <div class="meta-pagination" id="meta-pagination">
      <button id="meta-prev-btn">&laquo; Prev</button>
      <span id="meta-page-info">1 / 1</span>
      <button id="meta-next-btn">Next &raquo;</button>
    </div>
    <div class="meta-add-title">Add Entry</div>
    <div class="row">
      <input id="meta-key" placeholder="Key">
      <input id="meta-value" placeholder="Value">
    </div>
    <button class="primary full-width" id="meta-add-btn">Add</button>
  </div>

  <div class="section">
    <div class="section-title">Algorithms</div>
    <div class="row">
      <input id="algo-start" placeholder="Start node">
      <input id="algo-end" placeholder="End node">
    </div>
    <div class="algo-grid">
      <button data-algo="bfs">BFS</button>
      <button data-algo="dfs">DFS</button>
      <button data-algo="shortest-path">Shortest Path</button>
      <button data-algo="topo-sort">Topo Sort</button>
      <button data-algo="cycle-detect">Cycle Detect</button>
      <button data-algo="components">Components</button>
      <button data-algo="roots">Roots</button>
      <button data-algo="leaves">Leaves</button>
      <button data-algo="ancestors">Ancestors</button>
      <button data-algo="descendants">Descendants</button>
    </div>
  </div>

  <div id="result-panel">
    <div class="result-header">
      <span class="result-title" id="result-title">Result</span>
      <button class="btn-sm" id="clear-result-btn">Clear</button>
    </div>
    <div id="result-content"></div>
  </div>

  <div id="info">
    <span class="desktop-hints">
      <kbd>Double-click</kbd> canvas to add node<br>
      <kbd>Click</kbd> node then another to add edge<br>
      <kbd>Drag</kbd> node to reposition<br>
      <kbd>Delete</kbd> / <kbd>Backspace</kbd> to remove selected<br>
      <kbd>Esc</kbd> to cancel / deselect
    </span>
    <span class="mobile-hints">
      Double-tap to add node<br>
      Long-press node to start edge<br>
      Drag to reposition<br>
      Tap to select
    </span>
  </div>
</div>

<div id="canvas-wrap">
  <canvas id="canvas"></canvas>
  <button id="menu-toggle" aria-label="Toggle menu">&#9776;</button>
  <div id="tooltip"></div>
  <div id="mode-indicator"></div>
  <div id="sidebar-overlay"></div>
  <div id="status-legend">
    <div class="legend-row"><div class="legend-dot" style="background:#1a1d27;border-color:#4a4f65"></div> Pending</div>
    <div class="legend-row"><div class="legend-dot" style="background:#1a1d40;border-color:#6c7bff"></div> Ready</div>
    <div class="legend-row"><div class="legend-dot" style="background:#3a3020;border-color:#fbbf24"></div> Running</div>
    <div class="legend-row"><div class="legend-dot" style="background:#1a3a30;border-color:#34d399"></div> Done</div>
  </div>
</div>

<div id="meta-fullscreen">
  <div class="meta-fs-panel">
    <div class="meta-fs-header">
      <span class="meta-fs-key">key</span>
      <span class="meta-fs-type">str</span>
      <button class="meta-fs-close">&times;</button>
    </div>
    <div class="meta-fs-body"><pre><code id="meta-fs-code"></code></pre></div>
  </div>
</div>

<script>
// ---- Constants & State ----
let state = { directed: true, nodes: [], edges: [], result: null };
let selected = null;       // { type: 'node'|'edge', id, from?, to? }
let edgeStart = null;      // node id when creating edge via click
let dragging = null;       // { id, offsetX, offsetY }
let hoveredNode = null;
let hoveredEdge = null;
let animStep = 0;          // for animated result highlighting
let animTimer = null;
let nodeCounter = 0;

const NODE_RADIUS = 22;
const COLORS = ['#6c7bff', '#34d399', '#f472b6', '#fbbf24', '#22d3ee', '#a78bfa', '#fb923c', '#4ade80'];

const STATUS_COLORS = {
  pending:  { fill: '#1a1d27', border: '#4a4f65' },
  ready:    { fill: '#1a1d40', border: '#6c7bff' },
  running:  { fill: '#3a3020', border: '#fbbf24' },
  done:     { fill: '#1a3a30', border: '#34d399' },
  failed:   { fill: '#3a1a1a', border: '#f87171' },
  skipped:  { fill: '#1a1d27', border: '#8b90a0' },
};

const TOUCH_NODE_RADIUS = 30;
const TOUCH_EDGE_THRESHOLD = 16;

// ---- Metadata state ----
let metaState = { items: [], total: 0, offset: 0, hasMore: false };
const META_PAGE_SIZE = 5;

// ---- DOM Refs ----
const $ = id => document.getElementById(id);
const dom = {
  canvas: $('canvas'),
  canvasWrap: $('canvas-wrap'),
  tooltip: $('tooltip'),
  modeEl: $('mode-indicator'),
  sidebar: $('sidebar'),
  sidebarOverlay: $('sidebar-overlay'),
  menuToggle: $('menu-toggle'),
  statusLegend: $('status-legend'),
  directedToggle: $('directed-toggle'),
  nodeId: $('node-id'),
  nodeLabel: $('node-label'),
  edgeFrom: $('edge-from'),
  edgeTo: $('edge-to'),
  edgeWeight: $('edge-weight'),
  algoStart: $('algo-start'),
  algoEnd: $('algo-end'),
  templateSelect: $('template-select'),
  templateDesc: $('template-desc'),
  loadTemplateBtn: $('load-template-btn'),
  resultPanel: $('result-panel'),
  resultTitle: $('result-title'),
  resultContent: $('result-content'),
  taskSection: $('task-section'),
  taskDoneCount: $('task-done-count'),
  taskPct: $('task-pct'),
  taskProgress: $('task-progress'),
  taskStatusCounts: $('task-status-counts'),
  taskNodeControls: $('task-node-controls'),
  taskNodeLabel: $('task-node-label'),
  taskStatusSelect: $('task-status-select'),
  metaSection: $('meta-section'),
  metaTargetLabel: $('meta-target-label'),
  metaEntries: $('meta-entries'),
  metaPagination: $('meta-pagination'),
  metaPageInfo: $('meta-page-info'),
  metaPrevBtn: $('meta-prev-btn'),
  metaNextBtn: $('meta-next-btn'),
  metaKey: $('meta-key'),
  metaValue: $('meta-value'),
  exportBtn: $('export-btn'),
  importBtn: $('import-btn'),
  importFile: $('import-file'),
};

const canvas = dom.canvas;
const ctx = canvas.getContext('2d');
const tooltip = dom.tooltip;

// ---- Utilities ----
function findNode(id) {
  return state.nodes.find(n => n.id === id);
}

function dpr() { return window.devicePixelRatio || 1; }

function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

function canvasCoords(e) {
  const rect = canvas.getBoundingClientRect();
  return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

function buildNodeTooltipHTML(nodeId) {
  const n = findNode(nodeId);
  if (!n) return '';
  const inDeg = state.edges.filter(e => e.to === nodeId).length;
  const outDeg = state.edges.filter(e => e.from === nodeId).length;
  const statusInfo = n.status ? `<div class="tt-detail">Status: ${n.status}</div>` : '';
  const metaInfo = n.metaCount > 0 ? `<div class="tt-detail">Metadata: ${n.metaCount} entries</div>` : '';
  return `<div class="tt-id">${esc(n.id)}</div><div class="tt-detail">In: ${inDeg} Out: ${outDeg}</div>${statusInfo}${metaInfo}`;
}

function positionTooltip(x, y) {
  tooltip.style.display = 'block';
  tooltip.style.left = (x + 14) + 'px';
  tooltip.style.top = (y - 10) + 'px';
}

function showMode(text) {
  dom.modeEl.textContent = text;
  dom.modeEl.classList.toggle('visible', !!text);
}

function edgeColor(highlighted, isSelected, isHovered) {
  return highlighted ? '#34d399' : isSelected ? '#fbbf24' : isHovered ? '#8b90ff' : '#3a3f55';
}

function handleSelection(pos, nodeId, edgeThreshold) {
  // Complete edge creation
  if (edgeStart && nodeId && edgeStart !== nodeId) {
    addEdgeAPI(edgeStart, nodeId);
    edgeStart = null;
    showMode('');
    return 'edge-complete';
  }
  if (nodeId) {
    selected = { type: 'node', id: nodeId };
  } else {
    const edge = hitTestEdge(pos.x, pos.y, edgeThreshold);
    if (edge) {
      selected = { type: 'edge', ...edge };
    } else {
      selected = null;
    }
    edgeStart = null;
    showMode('');
  }
  updateTaskControls();
  updateMetaPanel();
  render();
  return nodeId ? 'node' : (selected ? 'edge' : null);
}

// ---- API Helpers ----
async function api(path, body) {
  const opts = { method: 'POST', headers: { 'Content-Type': 'application/json' } };
  if (body !== undefined) opts.body = JSON.stringify(body);
  const res = await fetch(path, opts);
  if (!res.ok) {
    const text = await res.text();
    throw new Error(text);
  }
  if (res.status === 204) return null;
  return res.json();
}

async function fetchGraph() {
  const res = await fetch('/api/graph');
  state = await res.json();
  updateTaskControls();
  render();
}

async function syncState(data) {
  if (data) {
    state = data;
    updateTaskControls();
    render();
  }
}

// ---- Actions ----
async function addNodeFromForm() {
  const id = dom.nodeId.value.trim();
  if (!id) return;
  const label = dom.nodeLabel.value.trim() || id;
  const cx = canvas.width / (2 * dpr());
  const cy = canvas.height / (2 * dpr());
  const x = cx + (Math.random() - 0.5) * 200;
  const y = cy + (Math.random() - 0.5) * 200;
  const data = await api('/api/node/add', { id, label, x, y });
  syncState(data);
  dom.nodeId.value = '';
  dom.nodeLabel.value = '';
  closeSidebarIfMobile();
}

async function addNodeAtPos(x, y) {
  nodeCounter++;
  const id = 'n' + nodeCounter;
  const data = await api('/api/node/add', { id, label: id, x, y });
  syncState(data);
}

async function removeNode(id) {
  const data = await api('/api/node/remove', { id });
  syncState(data);
}

async function addEdgeFromForm() {
  const from = dom.edgeFrom.value.trim();
  const to = dom.edgeTo.value.trim();
  const weight = parseFloat(dom.edgeWeight.value) || 1;
  if (!from || !to) return;
  const data = await api('/api/edge/add', { from, to, weight });
  syncState(data);
  dom.edgeFrom.value = '';
  dom.edgeTo.value = '';
  closeSidebarIfMobile();
}

async function addEdgeAPI(from, to) {
  const weight = parseFloat(dom.edgeWeight.value) || 1;
  const data = await api('/api/edge/add', { from, to, weight });
  syncState(data);
}

async function removeEdge(from, to) {
  const data = await api('/api/edge/remove', { from, to });
  syncState(data);
}

async function clearGraph() {
  const data = await api('/api/graph/clear', {});
  syncState(data);
  clearResult();
  selected = null;
  updateMetaPanel();
  nodeCounter = 0;
}

async function updateNodePos(id, x, y) {
  api('/api/node/position', { id, x, y });
  const n = findNode(id);
  if (n) { n.x = x; n.y = y; }
}

async function runAlgo(algo) {
  clearResult();
  const start = dom.algoStart.value.trim();
  const end = dom.algoEnd.value.trim();
  const data = await api('/api/algo?algo=' + algo, { start, end });
  syncState(data);
  if (data.result) showResult(data.result);
  closeSidebarIfMobile();
}

// ---- Rendering ----
function resize() {
  const r = dpr();
  canvas.width = dom.canvasWrap.clientWidth * r;
  canvas.height = dom.canvasWrap.clientHeight * r;
  ctx.setTransform(r, 0, 0, r, 0, 0);
  render();
}

function nodeColor(id) {
  const n = findNode(id);
  if (n && n.status && STATUS_COLORS[n.status]) {
    return STATUS_COLORS[n.status].border;
  }
  if (state.result && state.result.components) {
    for (let i = 0; i < state.result.components.length; i++) {
      if (state.result.components[i].includes(id)) return COLORS[i % COLORS.length];
    }
  }
  return '#6c7bff';
}

function isHighlightedNode(id) {
  if (!state.result || !state.result.highlightNodes) return false;
  const idx = state.result.highlightNodes.indexOf(id);
  if (idx === -1) return false;
  if (animTimer) return idx < animStep;
  return true;
}

function isHighlightedEdge(from, to) {
  if (!state.result || !state.result.highlightEdges) return false;
  return state.result.highlightEdges.some(e => e[0] === from && e[1] === to);
}

function getNodePos(id) {
  const n = findNode(id);
  return n ? { x: n.x, y: n.y } : null;
}

function drawGrid(w, h) {
  ctx.strokeStyle = '#1a1d27';
  ctx.lineWidth = 1;
  const gridSize = 40;
  for (let x = 0; x < w; x += gridSize) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
  }
  for (let y = 0; y < h; y += gridSize) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
  }
}

function drawEdges() {
  for (const e of state.edges) {
    const from = getNodePos(e.from);
    const to = getNodePos(e.to);
    if (!from || !to) continue;

    const highlighted = isHighlightedEdge(e.from, e.to);
    const isSelected = selected && selected.type === 'edge' && selected.from === e.from && selected.to === e.to;
    const isHovered = hoveredEdge && hoveredEdge.from === e.from && hoveredEdge.to === e.to;
    const color = edgeColor(highlighted, isSelected, isHovered);
    const lineWidth = highlighted || isSelected ? 2.5 : 1.5;

    // Self-loop
    if (e.from === e.to) {
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.beginPath();
      ctx.arc(from.x, from.y - NODE_RADIUS - 15, 15, 0.3, Math.PI * 2 - 0.3);
      ctx.stroke();
      if (state.directed) {
        drawArrowArc(from.x, from.y - NODE_RADIUS - 15, 15, -0.3, color);
      }
      continue;
    }

    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist === 0) continue;
    const ux = dx / dist;
    const uy = dy / dist;

    const sx = from.x + ux * NODE_RADIUS;
    const sy = from.y + uy * NODE_RADIUS;
    const ex = to.x - ux * NODE_RADIUS;
    const ey = to.y - uy * NODE_RADIUS;

    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(ex, ey);
    ctx.stroke();

    // Arrow for directed
    if (state.directed) {
      const arrowLen = 10;
      const angle = Math.atan2(ey - sy, ex - sx);
      ctx.fillStyle = ctx.strokeStyle;
      ctx.beginPath();
      ctx.moveTo(ex, ey);
      ctx.lineTo(ex - arrowLen * Math.cos(angle - 0.3), ey - arrowLen * Math.sin(angle - 0.3));
      ctx.lineTo(ex - arrowLen * Math.cos(angle + 0.3), ey - arrowLen * Math.sin(angle + 0.3));
      ctx.closePath();
      ctx.fill();
    }

    // Weight label
    if (e.weight !== 0 && e.weight !== 1) {
      const mx = (sx + ex) / 2;
      const my = (sy + ey) / 2;
      const nx = -uy * 12;
      const ny = ux * 12;
      ctx.fillStyle = '#8b90a0';
      ctx.font = '11px -apple-system, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(e.weight), mx + nx, my + ny);
    }
  }
}

function drawEdgePreview() {
  if (!edgeStart) return;
  const from = getNodePos(edgeStart);
  if (!from || !mousePos) return;
  ctx.strokeStyle = 'rgba(108, 123, 255, 0.4)';
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 4]);
  ctx.beginPath();
  ctx.moveTo(from.x, from.y);
  ctx.lineTo(mousePos.x, mousePos.y);
  ctx.stroke();
  ctx.setLineDash([]);
}

function drawNodes() {
  for (const n of state.nodes) {
    const highlighted = isHighlightedNode(n.id);
    const isSel = selected && selected.type === 'node' && selected.id === n.id;
    const isEdgeSource = edgeStart === n.id;
    const isHovered = hoveredNode === n.id;
    const sc = n.status && STATUS_COLORS[n.status] ? STATUS_COLORS[n.status] : null;

    // Glow
    if (highlighted || isSel) {
      const glowColor = highlighted ? 'rgba(52, 211, 153, 0.25)' : 'rgba(251, 191, 36, 0.25)';
      ctx.beginPath();
      ctx.arc(n.x, n.y, NODE_RADIUS + 6, 0, Math.PI * 2);
      ctx.fillStyle = glowColor;
      ctx.fill();
    }

    // Node circle
    ctx.beginPath();
    ctx.arc(n.x, n.y, NODE_RADIUS, 0, Math.PI * 2);
    if (sc && !highlighted && !isSel && !isEdgeSource) {
      ctx.fillStyle = sc.fill;
    } else {
      ctx.fillStyle = highlighted ? '#1a3a30' : isSel ? '#3a3020' : isEdgeSource ? '#1a2040' : '#1a1d27';
    }
    ctx.fill();
    if (sc && !highlighted && !isSel && !isEdgeSource) {
      ctx.strokeStyle = isHovered ? '#fff' : sc.border;
      ctx.lineWidth = 2.5;
    } else {
      ctx.strokeStyle = highlighted ? '#34d399' : isSel ? '#fbbf24' : isEdgeSource ? '#6c7bff' : isHovered ? '#6c7bff' : '#3a3f55';
      ctx.lineWidth = highlighted || isSel || isEdgeSource ? 2.5 : 1.5;
    }
    ctx.stroke();

    // Status icon (top-right of node)
    if (sc) {
      const ix = n.x + NODE_RADIUS * 0.6;
      const iy = n.y - NODE_RADIUS * 0.6;
      ctx.font = 'bold 10px -apple-system, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      if (n.status === 'done') { ctx.fillStyle = '#34d399'; ctx.fillText('\u2713', ix, iy); }
      else if (n.status === 'failed') { ctx.fillStyle = '#f87171'; ctx.fillText('\u2717', ix, iy); }
      else if (n.status === 'running') { ctx.fillStyle = '#fbbf24'; ctx.fillText('\u25CF', ix, iy); }
      else if (n.status === 'ready') { ctx.fillStyle = '#6c7bff'; ctx.fillText('\u25B6', ix, iy); }
      else if (n.status === 'skipped') { ctx.fillStyle = '#8b90a0'; ctx.fillText('\u2212', ix, iy); }
    }

    // Metadata indicator (bottom-right dot)
    if (n.metaCount > 0) {
      ctx.beginPath();
      ctx.arc(n.x + NODE_RADIUS * 0.65, n.y + NODE_RADIUS * 0.65, 4, 0, Math.PI * 2);
      ctx.fillStyle = '#a78bfa';
      ctx.fill();
    }

    // Step number for animated traversal
    if (highlighted && state.result && state.result.highlightNodes) {
      const idx = state.result.highlightNodes.indexOf(n.id);
      if (idx >= 0) {
        ctx.fillStyle = '#34d399';
        ctx.font = 'bold 9px -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(String(idx + 1), n.x + NODE_RADIUS - 4, n.y - NODE_RADIUS + 4);
      }
    }

    // Label
    if (sc && !highlighted && !isSel) {
      ctx.fillStyle = sc.border;
    } else {
      ctx.fillStyle = highlighted ? '#34d399' : isSel ? '#fbbf24' : '#e1e4ed';
    }
    ctx.font = '13px -apple-system, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(n.label || n.id, n.x, n.y);
  }
}

function drawStats(w, h) {
  ctx.fillStyle = '#4a4f65';
  ctx.font = '12px -apple-system, sans-serif';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'bottom';
  ctx.fillText(`${state.nodes.length} nodes \u00b7 ${state.edges.length} edges`, w - 12, h - 12);
}

function render() {
  const w = canvas.width / dpr();
  const h = canvas.height / dpr();
  ctx.clearRect(0, 0, w, h);
  drawGrid(w, h);
  drawEdges();
  drawEdgePreview();
  drawNodes();
  drawStats(w, h);
}

function drawArrowArc(cx, cy, r, endAngle, color) {
  const ax = cx + r * Math.cos(endAngle);
  const ay = cy + r * Math.sin(endAngle);
  const angle = endAngle + Math.PI / 2;
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(ax, ay);
  ctx.lineTo(ax - 8 * Math.cos(angle - 0.4), ay - 8 * Math.sin(angle - 0.4));
  ctx.lineTo(ax - 8 * Math.cos(angle + 0.4), ay - 8 * Math.sin(angle + 0.4));
  ctx.closePath();
  ctx.fill();
}

// ---- Hit Testing ----
function hitTestNode(x, y, radius) {
  const r = radius || NODE_RADIUS;
  for (let i = state.nodes.length - 1; i >= 0; i--) {
    const n = state.nodes[i];
    const dx = x - n.x, dy = y - n.y;
    if (dx * dx + dy * dy <= r * r) return n.id;
  }
  return null;
}

function hitTestEdge(x, y, threshold) {
  threshold = threshold || 8;
  for (const e of state.edges) {
    const from = getNodePos(e.from);
    const to = getNodePos(e.to);
    if (!from || !to) continue;
    if (e.from === e.to) continue; // skip self-loops for now
    const d = distToSegment(x, y, from.x, from.y, to.x, to.y);
    if (d < threshold) return { from: e.from, to: e.to };
  }
  return null;
}

function distToSegment(px, py, x1, y1, x2, y2) {
  const dx = x2 - x1, dy = y2 - y1;
  const lenSq = dx * dx + dy * dy;
  if (lenSq === 0) return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
  let t = ((px - x1) * dx + (py - y1) * dy) / lenSq;
  t = Math.max(0, Math.min(1, t));
  const cx = x1 + t * dx, cy = y1 + t * dy;
  return Math.sqrt((px - cx) ** 2 + (py - cy) ** 2);
}

// ---- Result Display ----
function showResult(result) {
  dom.resultPanel.classList.add('visible');
  dom.resultTitle.textContent = result.algorithm.replace('-', ' ').toUpperCase();

  if (result.error) {
    dom.resultContent.innerHTML = `<span class="error">${esc(result.error)}</span>`;
    return;
  }

  let html = '';
  if (result.visitedOrder) {
    html += `<div>Order: <span class="highlight">${result.visitedOrder.join(' \u2192 ')}</span></div>`;
  }
  if (result.path) {
    html += `<div>Path: <span class="highlight">${result.path.join(' \u2192 ')}</span></div>`;
    html += `<div>Cost: <span class="highlight">${result.cost}</span></div>`;
  }
  if (result.hasCycle !== undefined) {
    html += `<div>Cycle: <span class="highlight">${result.hasCycle ? 'Yes' : 'No'}</span></div>`;
    if (result.cycle && result.cycle.length) {
      html += `<div><span class="highlight">${result.cycle.join(' \u2192 ')} \u2192 ${result.cycle[0]}</span></div>`;
    }
  }
  if (result.components && result.components.length) {
    result.components.forEach((c, i) => {
      html += `<div>Component ${i + 1}: <span class="highlight">${c.join(', ')}</span></div>`;
    });
  }
  if (result.roots && result.roots.length) {
    html += `<div>Roots: <span class="highlight">${result.roots.join(', ')}</span></div>`;
  }
  if (result.leaves && result.leaves.length) {
    html += `<div>Leaves: <span class="highlight">${result.leaves.join(', ')}</span></div>`;
  }
  if (result.ancestors && result.ancestors.length) {
    html += `<div>Ancestors: <span class="highlight">${result.ancestors.join(', ')}</span></div>`;
  }
  if (result.descendants && result.descendants.length) {
    html += `<div>Descendants: <span class="highlight">${result.descendants.join(', ')}</span></div>`;
  }
  dom.resultContent.innerHTML = html || '<span class="highlight">No results</span>';

  // Animate stepping through highlighted nodes
  if (result.highlightNodes && result.highlightNodes.length > 1) {
    animStep = 0;
    if (animTimer) clearInterval(animTimer);
    animTimer = setInterval(() => {
      animStep++;
      if (animStep >= result.highlightNodes.length) {
        animStep = result.highlightNodes.length;
        clearInterval(animTimer);
        animTimer = null;
      }
      render();
    }, 400);
  }
  render();
}

function clearResult() {
  state.result = null;
  dom.resultPanel.classList.remove('visible');
  if (animTimer) { clearInterval(animTimer); animTimer = null; }
  animStep = 0;
  render();
}

// ---- Task Controls ----
function hasTaskNodes() {
  return state.nodes.some(n => n.status);
}

function updateTaskControls() {
  const hasTasks = hasTaskNodes();
  dom.taskSection.classList.toggle('visible', hasTasks);
  dom.statusLegend.classList.toggle('visible', hasTasks);
  if (!hasTasks) return;

  const counts = { pending: 0, ready: 0, running: 0, done: 0, failed: 0, skipped: 0 };
  const taskNodes = state.nodes.filter(n => n.status);
  for (const n of taskNodes) {
    if (counts[n.status] !== undefined) counts[n.status]++;
  }
  const total = taskNodes.length;
  const doneCount = counts.done;
  const pct = total > 0 ? Math.round(doneCount / total * 100) : 0;

  dom.taskDoneCount.textContent = doneCount + '/' + total;
  dom.taskPct.textContent = pct;
  dom.taskProgress.style.width = pct + '%';

  const dotColors = { pending: '#4a4f65', ready: '#6c7bff', running: '#fbbf24', done: '#34d399', failed: '#f87171', skipped: '#8b90a0' };
  let html = '';
  for (const [s, c] of Object.entries(counts)) {
    if (c > 0) {
      html += `<span><span class="status-dot" style="background:${dotColors[s]}"></span>${c} ${s}</span>`;
    }
  }
  dom.taskStatusCounts.innerHTML = html;

  // Node-specific controls
  if (selected && selected.type === 'node') {
    const n = findNode(selected.id);
    if (n && n.status) {
      dom.taskNodeControls.classList.add('visible');
      dom.taskNodeLabel.textContent = n.label || n.id;
      dom.taskStatusSelect.value = n.status;
    } else {
      dom.taskNodeControls.classList.remove('visible');
    }
  } else {
    dom.taskNodeControls.classList.remove('visible');
  }
}

async function updateNodeStatus() {
  if (!selected || selected.type !== 'node') return;
  const status = dom.taskStatusSelect.value;
  const data = await api('/api/node/status', { id: selected.id, status });
  syncState(data);
}

async function resetAllStatuses() {
  for (const n of state.nodes) {
    if (n.status) {
      await api('/api/node/status', { id: n.id, status: 'pending' });
    }
  }
  const res = await fetch('/api/graph');
  const data = await res.json();
  syncState(data);
}

// ---- Metadata Panel ----
function inferType(value) {
  if (value === null || value === undefined) return 'null';
  if (typeof value === 'string') return 'str';
  if (typeof value === 'number') return 'num';
  if (typeof value === 'boolean') return 'bool';
  if (Array.isArray(value)) return 'arr';
  if (typeof value === 'object') return 'obj';
  return 'any';
}

function formatValue(value) {
  if (value === null || value === undefined) return 'null';
  if (typeof value === 'string') return '"' + value + '"';
  if (typeof value === 'boolean') return value ? 'true' : 'false';
  if (typeof value === 'object') {
    const s = JSON.stringify(value);
    return s.length > 80 ? s.substring(0, 77) + '...' : s;
  }
  return String(value);
}

async function fetchNodeMeta(nodeId, offset) {
  try {
    const data = await api('/api/node/meta', { id: nodeId, offset: offset || 0, limit: META_PAGE_SIZE });
    metaState = data;
    renderMetaEntries();
  } catch(e) {
    metaState = { items: [], total: 0, offset: 0, hasMore: false };
    renderMetaEntries();
  }
}

async function fetchEdgeMeta(from, to, offset) {
  try {
    const data = await api('/api/edge/meta', { from, to, offset: offset || 0, limit: META_PAGE_SIZE });
    metaState = data;
    renderMetaEntries();
  } catch(e) {
    metaState = { items: [], total: 0, offset: 0, hasMore: false };
    renderMetaEntries();
  }
}

function updateMetaPanel() {
  if (selected && selected.type === 'node') {
    dom.metaSection.style.display = 'block';
    const n = findNode(selected.id);
    dom.metaTargetLabel.innerHTML = 'Node: <strong>' + esc(n ? (n.label || n.id) : selected.id) + '</strong>';
    fetchNodeMeta(selected.id, 0);
  } else if (selected && selected.type === 'edge') {
    dom.metaSection.style.display = 'block';
    dom.metaTargetLabel.innerHTML = 'Edge: <strong>' + esc(selected.from) + ' \u2192 ' + esc(selected.to) + '</strong>';
    fetchEdgeMeta(selected.from, selected.to, 0);
  } else {
    dom.metaSection.style.display = 'none';
    metaState = { items: [], total: 0, offset: 0, hasMore: false };
  }
}

function renderMetaEntries() {
  const container = dom.metaEntries;
  if (metaState.items.length === 0 && metaState.total === 0) {
    container.innerHTML = '<div class="meta-empty">No metadata entries</div>';
    dom.metaPagination.style.display = 'none';
    return;
  }

  let html = '';
  for (const item of metaState.items) {
    const typeTag = inferType(item.value);
    const displayVal = formatValue(item.value);
    html += `<div class="meta-entry">
      <div class="meta-entry-header">
        <span class="meta-key">${esc(item.key)}</span>
        <span class="meta-type">${typeTag}</span>
        <button class="meta-del-btn" data-key="${esc(item.key)}">\u00d7</button>
      </div>
      <div class="meta-value">${esc(displayVal)}</div>
    </div>`;
  }
  container.innerHTML = html;

  // Wire delete buttons
  container.querySelectorAll('.meta-del-btn').forEach(btn => {
    btn.addEventListener('click', (e) => { e.stopPropagation(); deleteMeta(btn.dataset.key); });
  });

  // Wire click-to-fullscreen on each entry
  container.querySelectorAll('.meta-entry').forEach((el, idx) => {
    el.addEventListener('click', () => {
      const item = metaState.items[idx];
      if (item) openMetaFullscreen(item.key, item.value);
    });
  });

  // Pagination
  if (metaState.total > META_PAGE_SIZE) {
    dom.metaPagination.style.display = 'flex';
    const page = Math.floor(metaState.offset / META_PAGE_SIZE) + 1;
    const totalPages = Math.ceil(metaState.total / META_PAGE_SIZE);
    dom.metaPageInfo.textContent = page + ' / ' + totalPages;
    dom.metaPrevBtn.disabled = metaState.offset === 0;
    dom.metaNextBtn.disabled = !metaState.hasMore;
  } else {
    dom.metaPagination.style.display = 'none';
  }
}

async function addMeta() {
  const key = dom.metaKey.value.trim();
  let rawValue = dom.metaValue.value.trim();
  if (!key || rawValue === '') return;

  // Try to parse as JSON (for numbers, booleans, arrays, objects)
  let value;
  try {
    value = JSON.parse(rawValue);
  } catch(e) {
    value = rawValue; // treat as string
  }

  if (selected && selected.type === 'node') {
    const data = await api('/api/node/meta/set', { id: selected.id, key, value });
    syncState(data);
    fetchNodeMeta(selected.id, metaState.offset);
  } else if (selected && selected.type === 'edge') {
    const data = await api('/api/edge/meta/set', { from: selected.from, to: selected.to, key, value });
    syncState(data);
    fetchEdgeMeta(selected.from, selected.to, metaState.offset);
  }

  dom.metaKey.value = '';
  dom.metaValue.value = '';
}

async function deleteMeta(key) {
  if (selected && selected.type === 'node') {
    const data = await api('/api/node/meta/delete', { id: selected.id, key });
    syncState(data);
    // If current page would be empty, go to previous page
    const newOffset = (metaState.items.length <= 1 && metaState.offset > 0)
      ? Math.max(0, metaState.offset - META_PAGE_SIZE) : metaState.offset;
    fetchNodeMeta(selected.id, newOffset);
  } else if (selected && selected.type === 'edge') {
    const data = await api('/api/edge/meta/delete', { from: selected.from, to: selected.to, key });
    syncState(data);
    const newOffset = (metaState.items.length <= 1 && metaState.offset > 0)
      ? Math.max(0, metaState.offset - META_PAGE_SIZE) : metaState.offset;
    fetchEdgeMeta(selected.from, selected.to, newOffset);
  }
}

function metaPrevPage() {
  const newOffset = Math.max(0, metaState.offset - META_PAGE_SIZE);
  if (selected && selected.type === 'node') {
    fetchNodeMeta(selected.id, newOffset);
  } else if (selected && selected.type === 'edge') {
    fetchEdgeMeta(selected.from, selected.to, newOffset);
  }
}

function metaNextPage() {
  if (!metaState.hasMore) return;
  const newOffset = metaState.offset + META_PAGE_SIZE;
  if (selected && selected.type === 'node') {
    fetchNodeMeta(selected.id, newOffset);
  } else if (selected && selected.type === 'edge') {
    fetchEdgeMeta(selected.from, selected.to, newOffset);
  }
}

// ---- Extension Filter ----
const activeExtensions = new Set();

const EXT_PRESETS = {
  code: ['.go', '.py', '.js', '.ts', '.java', '.c', '.cpp', '.rs', '.rb', '.jsx', '.tsx', '.cs', '.swift', '.kt', '.scala', '.sh', '.bash', '.pl', '.php', '.lua', '.zig', '.hs'],
  config: ['.json', '.yaml', '.yml', '.toml', '.xml', '.env', '.ini', '.cfg', '.conf', '.properties'],
  docs: ['.md', '.txt', '.rst', '.adoc', '.tex'],
};

function addExtension(ext) {
  ext = ext.trim().toLowerCase();
  if (!ext) return;
  if (ext[0] !== '.') ext = '.' + ext;
  if (activeExtensions.has(ext)) return;
  activeExtensions.add(ext);
  renderExtChips();
}

function removeExtension(ext) {
  activeExtensions.delete(ext);
  renderExtChips();
}

function renderExtChips() {
  const container = $('ext-chips');
  if (activeExtensions.size === 0) {
    container.innerHTML = '';
    return;
  }
  let html = '';
  for (const ext of activeExtensions) {
    html += `<span class="ext-chip">${esc(ext)}<span class="ext-chip-x" data-ext="${esc(ext)}">&times;</span></span>`;
  }
  container.innerHTML = html;
  container.querySelectorAll('.ext-chip-x').forEach(el => {
    el.addEventListener('click', () => removeExtension(el.dataset.ext));
  });
}

function addExtensionsFromInput() {
  const input = $('ext-input');
  const raw = input.value;
  if (!raw.trim()) return;
  // Split on commas, spaces, or both
  const parts = raw.split(/[,\s]+/);
  for (const p of parts) addExtension(p);
  input.value = '';
}

$('ext-add-btn').addEventListener('click', addExtensionsFromInput);
$('ext-input').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') { e.preventDefault(); addExtensionsFromInput(); }
});

document.querySelector('.ext-presets').addEventListener('click', (e) => {
  const preset = e.target.dataset.preset;
  if (preset && EXT_PRESETS[preset]) {
    for (const ext of EXT_PRESETS[preset]) addExtension(ext);
  }
});

$('ext-clear-btn').addEventListener('click', () => {
  activeExtensions.clear();
  renderExtChips();
});

// ---- Directory Upload ----
const BINARY_EXTENSIONS = new Set([
  '.png','.jpg','.jpeg','.gif','.bmp','.ico','.webp','.svg',
  '.woff','.woff2','.ttf','.eot','.otf',
  '.zip','.gz','.tar','.bz2','.7z','.rar','.xz',
  '.exe','.dll','.so','.dylib','.bin','.obj','.o','.a',
  '.pdf','.doc','.docx','.xls','.xlsx','.ppt','.pptx',
  '.mp3','.mp4','.avi','.mov','.mkv','.wav','.flac','.ogg','.webm',
  '.class','.pyc','.pyo','.wasm',
  '.db','.sqlite','.sqlite3',
]);
const MAX_CONTENT_SIZE = 100 * 1024; // 100KB

function isBinaryFile(name) {
  const dot = name.lastIndexOf('.');
  if (dot === -1) return false;
  return BINARY_EXTENSIONS.has(name.substring(dot).toLowerCase());
}

async function handleDirectoryUpload(e) {
  const files = e.target.files;
  if (!files || files.length === 0) return;

  const includeContent = $('dir-include-content').checked;
  const progressDiv = $('dir-progress');
  const progressFill = $('dir-progress-fill');
  const progressText = $('dir-progress-text');

  progressDiv.style.display = 'block';
  progressFill.style.width = '0%';
  progressText.textContent = `Processing ${files.length} files...`;

  // Determine root name from the first file's relative path.
  const firstPath = files[0].webkitRelativePath || '';
  const rootName = firstPath.split('/')[0] || 'directory';

  // Collect unique directories and file entries.
  const dirSet = new Set();
  const fileEntries = [];

  for (const file of files) {
    const relPath = file.webkitRelativePath;
    if (!relPath) continue;

    // Path without root prefix (rootName/rest/of/path).
    const parts = relPath.split('/');
    // Build intermediate directory paths.
    for (let i = 1; i < parts.length - 1; i++) {
      dirSet.add(parts.slice(1, i + 1).join('/'));
    }
    // File path relative to root.
    const filePath = parts.slice(1).join('/');
    if (filePath) {
      fileEntries.push({ file, path: filePath, name: parts[parts.length - 1] });
    }
  }

  // Build entries array for the API.
  const entries = [];

  // Add directory entries.
  for (const dirPath of dirSet) {
    const dirName = dirPath.split('/').pop();
    entries.push({ path: dirPath, name: dirName, isDir: true, size: 0 });
  }

  // Read file contents in batches for efficiency.
  const BATCH_SIZE = 20;
  let processed = 0;

  for (let i = 0; i < fileEntries.length; i += BATCH_SIZE) {
    const batch = fileEntries.slice(i, i + BATCH_SIZE);
    const results = await Promise.all(batch.map(async ({ file, path, name }) => {
      const entry = { path, name, isDir: false, size: file.size };
      if (includeContent && !isBinaryFile(name) && file.size <= MAX_CONTENT_SIZE) {
        try {
          entry.content = await file.text();
        } catch (err) {
          // Skip unreadable files.
        }
      }
      return entry;
    }));

    entries.push(...results);
    processed += batch.length;

    const pct = Math.round((processed / fileEntries.length) * 100);
    progressFill.style.width = pct + '%';
    progressText.textContent = `Reading files... ${processed}/${fileEntries.length}`;

    // Yield to UI thread between batches.
    if (i + BATCH_SIZE < fileEntries.length) {
      await new Promise(r => setTimeout(r, 0));
    }
  }

  progressText.textContent = 'Uploading to server...';
  progressFill.style.width = '100%';

  try {
    const extensions = activeExtensions.size > 0 ? Array.from(activeExtensions) : [];
    const data = await api('/api/directory/load', { rootName, entries, extensions });
    selected = null;
    edgeStart = null;
    showMode('');
    syncState(data);
    dom.directedToggle.checked = data.directed;
    clearResult();
    updateMetaPanel();
    nodeCounter = 0;
    syncNodeCounter();
    closeSidebarIfMobile();
  } catch (err) {
    console.error('Directory upload failed:', err);
    progressText.textContent = 'Upload failed: ' + err.message;
    setTimeout(() => { progressDiv.style.display = 'none'; }, 3000);
    e.target.value = '';
    return;
  }

  progressDiv.style.display = 'none';
  e.target.value = '';
}

// ---- Export / Import ----
async function exportGraph() {
  try {
    const res = await fetch('/api/graph/export');
    if (!res.ok) throw new Error(await res.text());
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'spine-graph.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  } catch(e) {
    console.error('Export failed:', e);
  }
}

async function handleImportFile(e) {
  const file = e.target.files[0];
  if (!file) return;
  try {
    const text = await file.text();
    const res = await fetch('/api/graph/import', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: text,
    });
    if (!res.ok) throw new Error(await res.text());
    const data = await res.json();
    selected = null;
    edgeStart = null;
    showMode('');
    syncState(data);
    dom.directedToggle.checked = data.directed;
    clearResult();
    updateMetaPanel();
    nodeCounter = 0;
    syncNodeCounter();
    closeSidebarIfMobile();
  } catch(e) {
    console.error('Import failed:', e);
  }
  dom.importFile.value = '';
}

// ---- Templates ----
let templateList = [];

async function fetchTemplates() {
  const res = await fetch('/api/templates');
  templateList = await res.json();
  templateList.forEach(t => {
    const opt = document.createElement('option');
    opt.value = t.id;
    opt.textContent = t.name;
    dom.templateSelect.appendChild(opt);
  });
}

function onTemplateSelect() {
  const id = dom.templateSelect.value;
  const t = templateList.find(t => t.id === id);
  if (t) {
    dom.templateDesc.textContent = t.description + ' (' + t.nodeCount + ' nodes, ' + t.edgeCount + ' edges)';
    dom.loadTemplateBtn.disabled = false;
  } else {
    dom.templateDesc.textContent = '';
    dom.loadTemplateBtn.disabled = true;
  }
}

async function loadTemplate() {
  const id = dom.templateSelect.value;
  if (!id) return;
  const data = await api('/api/template/load', { id });
  selected = null;
  syncState(data);
  updateMetaPanel();
  clearResult();
  dom.directedToggle.checked = data.directed;
  nodeCounter = 0;
  syncNodeCounter();
  closeSidebarIfMobile();
}

function syncNodeCounter() {
  for (const n of state.nodes) {
    const m = n.id.match(/^n(\d+)$/);
    if (m) nodeCounter = Math.max(nodeCounter, parseInt(m[1]));
  }
}

// ---- Sidebar ----
function openSidebar() {
  dom.sidebar.classList.add('open');
  dom.sidebarOverlay.classList.add('visible');
}

function closeSidebar() {
  dom.sidebar.classList.remove('open');
  dom.sidebarOverlay.classList.remove('visible');
}

function closeSidebarIfMobile() {
  if (window.innerWidth <= 767) closeSidebar();
}

// ---- Event Handlers: Mouse ----
let mousePos = null;
let lastClick = 0;

function onMouseDown(e) {
  const pos = canvasCoords(e);
  const now = Date.now();
  const nodeId = hitTestNode(pos.x, pos.y);

  // Double click to create node
  if (now - lastClick < 300 && !nodeId) {
    addNodeAtPos(pos.x, pos.y);
    lastClick = 0;
    return;
  }
  lastClick = now;

  const result = handleSelection(pos, nodeId);
  if (result === 'node') {
    const n = findNode(nodeId);
    dragging = { id: nodeId, offsetX: pos.x - n.x, offsetY: pos.y - n.y };
  }
}

function onMouseMove(e) {
  const pos = canvasCoords(e);
  mousePos = pos;

  if (dragging) {
    const n = findNode(dragging.id);
    if (n) {
      n.x = pos.x - dragging.offsetX;
      n.y = pos.y - dragging.offsetY;
      render();
    }
    return;
  }

  // Hover detection
  const nodeId = hitTestNode(pos.x, pos.y);
  const edge = nodeId ? null : hitTestEdge(pos.x, pos.y);
  const changed = hoveredNode !== nodeId || (hoveredEdge?.from !== edge?.from || hoveredEdge?.to !== edge?.to);
  hoveredNode = nodeId;
  hoveredEdge = edge;

  if (changed) render();

  // Tooltip
  if (nodeId) {
    tooltip.innerHTML = buildNodeTooltipHTML(nodeId);
    positionTooltip(pos.x, pos.y);
  } else if (edge) {
    const ed = state.edges.find(x => x.from === edge.from && x.to === edge.to);
    let ttHtml = `<div class="tt-id">${esc(edge.from)} \u2192 ${esc(edge.to)}</div><div class="tt-detail">Weight: ${ed ? ed.weight : '?'}</div>`;
    if (ed && ed.metaCount > 0) {
      ttHtml += `<div class="tt-detail">Metadata: ${ed.metaCount} entries</div>`;
    }
    tooltip.innerHTML = ttHtml;
    positionTooltip(pos.x, pos.y);
  } else {
    tooltip.style.display = 'none';
  }

  // Redraw edge preview
  if (edgeStart) render();

  canvas.style.cursor = nodeId ? 'grab' : edge ? 'pointer' : edgeStart ? 'crosshair' : 'default';
}

function onMouseUp() {
  if (dragging) {
    const n = findNode(dragging.id);
    if (n) updateNodePos(dragging.id, n.x, n.y);
    dragging = null;
  }
}

function onMouseLeave() {
  tooltip.style.display = 'none';
  hoveredNode = null;
  hoveredEdge = null;
  mousePos = null;
  render();
}

// ---- Event Handlers: Touch ----
let touchStartTime = 0;
let touchStartPos = null;
let touchNodeId = null;
let touchMoved = false;
let touchDragging = false;
let longPressTimer = null;
let lastTapTime = 0;
let tooltipTimer = null;

function showNodeTooltip(nodeId, pos) {
  const html = buildNodeTooltipHTML(nodeId);
  if (!html) return;
  tooltip.innerHTML = html;
  positionTooltip(pos.x, pos.y);
  if (tooltipTimer) clearTimeout(tooltipTimer);
  tooltipTimer = setTimeout(() => { tooltip.style.display = 'none'; }, 2000);
}

function onTouchStart(e) {
  if (dom.sidebar.classList.contains('open')) return;
  e.preventDefault();
  const pos = canvasCoords(e.touches[0]);
  touchStartTime = Date.now();
  touchStartPos = pos;
  touchMoved = false;
  touchDragging = false;
  touchNodeId = hitTestNode(pos.x, pos.y, TOUCH_NODE_RADIUS);

  // Start long-press timer if on a node
  if (longPressTimer) clearTimeout(longPressTimer);
  if (touchNodeId) {
    longPressTimer = setTimeout(() => {
      if (!touchMoved && touchNodeId) {
        // Long press: enter edge creation mode
        edgeStart = touchNodeId;
        selected = { type: 'node', id: touchNodeId };
        showMode('Edge mode: tap target node');
        render();
        longPressTimer = null;
      }
    }, 500);
  }
}

function onTouchMove(e) {
  if (dom.sidebar.classList.contains('open')) return;
  e.preventDefault();
  const pos = canvasCoords(e.touches[0]);

  if (!touchMoved && touchStartPos) {
    const dx = pos.x - touchStartPos.x;
    const dy = pos.y - touchStartPos.y;
    if (dx * dx + dy * dy > 100) { // 10px threshold
      touchMoved = true;
      if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
    }
  }

  if (touchMoved && touchNodeId && !edgeStart) {
    // Drag node
    touchDragging = true;
    const n = findNode(touchNodeId);
    if (n) {
      n.x = pos.x;
      n.y = pos.y;
      render();
    }
  }

  // Update mousePos for edge preview line
  if (edgeStart) {
    mousePos = pos;
    render();
  }
}

function onTouchEnd(e) {
  if (dom.sidebar.classList.contains('open')) return;
  e.preventDefault();
  if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }

  const pos = touchStartPos;
  if (!pos) return;

  // If we were dragging, finalize position
  if (touchDragging && touchNodeId) {
    const n = findNode(touchNodeId);
    if (n) updateNodePos(touchNodeId, n.x, n.y);
    touchDragging = false;
    touchNodeId = null;
    touchStartPos = null;
    return;
  }

  // Only process taps (not drags, not long-press)
  if (touchMoved) { touchStartPos = null; return; }

  const elapsed = Date.now() - touchStartTime;
  // Ignore if long-press already triggered edge mode
  if (elapsed >= 500 && edgeStart) { touchStartPos = null; return; }

  const now = Date.now();
  const nodeId = hitTestNode(pos.x, pos.y, TOUCH_NODE_RADIUS);

  // Double-tap detection
  if (now - lastTapTime < 300 && !nodeId) {
    addNodeAtPos(pos.x, pos.y);
    lastTapTime = 0;
    touchStartPos = null;
    return;
  }
  lastTapTime = now;

  const result = handleSelection(pos, nodeId, TOUCH_EDGE_THRESHOLD);
  if (result === 'node') {
    showNodeTooltip(nodeId, pos);
  }
  touchStartPos = null;
}

// ---- Event Handlers: Keyboard ----
function onKeyDown(e) {
  if (e.target.tagName === 'INPUT') return;

  if (e.key === 'Escape') {
    if (metaFS.classList.contains('visible')) {
      closeMetaFullscreen();
      return;
    }
    selected = null;
    edgeStart = null;
    showMode('');
    clearResult();
    updateTaskControls();
    updateMetaPanel();
    render();
  }

  if ((e.key === 'Delete' || e.key === 'Backspace') && selected) {
    if (selected.type === 'node') removeNode(selected.id);
    else if (selected.type === 'edge') removeEdge(selected.from, selected.to);
    selected = null;
    updateTaskControls();
    updateMetaPanel();
  }

  // 'e' to start edge mode from selected node
  if (e.key === 'e' && selected && selected.type === 'node') {
    edgeStart = selected.id;
    showMode('Edge mode: click target node');
    render();
  }
}

// ---- Event Bindings ----

// Sidebar
dom.menuToggle.addEventListener('click', () => {
  if (dom.sidebar.classList.contains('open')) closeSidebar();
  else openSidebar();
});
dom.sidebarOverlay.addEventListener('click', closeSidebar);

// Graph controls
dom.directedToggle.addEventListener('change', async (e) => {
  const data = await api('/api/graph/directed', { directed: e.target.checked });
  syncState(data);
});
$('clear-graph-btn').addEventListener('click', clearGraph);

// Export / Import
dom.exportBtn.addEventListener('click', exportGraph);
dom.importBtn.addEventListener('click', () => dom.importFile.click());
dom.importFile.addEventListener('change', handleImportFile);

// Directory upload
$('dir-upload-btn').addEventListener('click', () => $('dir-upload-file').click());
$('dir-upload-file').addEventListener('change', handleDirectoryUpload);

// Templates
dom.templateSelect.addEventListener('change', onTemplateSelect);
dom.loadTemplateBtn.addEventListener('click', loadTemplate);

// Node/Edge forms
$('add-node-btn').addEventListener('click', addNodeFromForm);
$('add-edge-btn').addEventListener('click', addEdgeFromForm);

// Task controls
$('update-status-btn').addEventListener('click', updateNodeStatus);
$('reset-all-btn').addEventListener('click', resetAllStatuses);

// Metadata controls
$('meta-add-btn').addEventListener('click', addMeta);
dom.metaPrevBtn.addEventListener('click', metaPrevPage);
dom.metaNextBtn.addEventListener('click', metaNextPage);

// Algorithms (event delegation)
document.querySelector('.algo-grid').addEventListener('click', (e) => {
  const algo = e.target.dataset.algo;
  if (algo) runAlgo(algo);
});

// Result
$('clear-result-btn').addEventListener('click', clearResult);

// Canvas
canvas.addEventListener('mousedown', onMouseDown);
canvas.addEventListener('mousemove', onMouseMove);
canvas.addEventListener('mouseup', onMouseUp);
canvas.addEventListener('mouseleave', onMouseLeave);
canvas.addEventListener('touchstart', onTouchStart, { passive: false });
canvas.addEventListener('touchmove', onTouchMove, { passive: false });
canvas.addEventListener('touchend', onTouchEnd, { passive: false });

// Keyboard & Window
document.addEventListener('keydown', onKeyDown);
window.addEventListener('resize', resize);

// ---- Init ----
resize();
fetchGraph();
fetchTemplates();
// ---- Fullscreen Metadata Viewer ----
const metaFS = document.getElementById('meta-fullscreen');
const metaFSKey = metaFS.querySelector('.meta-fs-key');
const metaFSType = metaFS.querySelector('.meta-fs-type');
const metaFSCode = document.getElementById('meta-fs-code');

// Map file extensions to highlight.js language names
function detectLanguage(key) {
  const ext = (key.match(/\.([a-zA-Z0-9]+)$/) || [])[1];
  if (!ext) return null;
  const map = {
    go: 'go', py: 'python', js: 'javascript', ts: 'typescript',
    jsx: 'javascript', tsx: 'typescript', rs: 'rust', java: 'java',
    c: 'c', h: 'c', cpp: 'cpp', hpp: 'cpp', cs: 'csharp',
    rb: 'ruby', php: 'php', swift: 'swift', kt: 'kotlin',
    scala: 'scala', sh: 'bash', bash: 'bash', zsh: 'bash',
    sql: 'sql', html: 'xml', xml: 'xml', css: 'css',
    scss: 'scss', less: 'less', json: 'json', yaml: 'yaml',
    yml: 'yaml', toml: 'ini', md: 'markdown', dockerfile: 'dockerfile',
    tf: 'hcl', proto: 'protobuf', r: 'r', lua: 'lua',
    zig: 'zig', dart: 'dart', ex: 'elixir', exs: 'elixir',
    erl: 'erlang', hs: 'haskell', ml: 'ocaml', vim: 'vim',
    makefile: 'makefile', cmake: 'cmake',
  };
  return map[ext.toLowerCase()] || null;
}

function openMetaFullscreen(key, value) {
  metaFSKey.textContent = key;
  const lang = detectLanguage(key);
  metaFSType.textContent = lang || inferType(value);

  let text;
  if (typeof value === 'string') {
    text = value;
  } else if (value === null || value === undefined) {
    text = 'null';
  } else {
    text = JSON.stringify(value, null, 2);
  }

  const isJSON = typeof value === 'object' && value !== null;

  // Use highlight.js for code files (when hljs is available and language detected)
  let highlightedLines;
  if (!isJSON && lang && typeof hljs !== 'undefined') {
    try {
      const result = hljs.highlight(text, { language: lang, ignoreIllegals: true });
      highlightedLines = result.value.split('\n');
    } catch (e) {
      highlightedLines = null;
    }
  }

  const lines = text.split('\n');
  let html = '';
  for (let i = 0; i < lines.length; i++) {
    const num = i + 1;
    let content;
    if (highlightedLines) {
      content = highlightedLines[i] || ' ';
    } else if (isJSON) {
      content = syntaxHighlightJSON(esc(lines[i]));
    } else {
      content = esc(lines[i]) || ' ';
    }
    html += '<span class="line-row"><span class="line-num">' + num + '</span><span class="line-content">' + content + '</span>\n</span>';
  }
  metaFSCode.innerHTML = html;
  metaFS.classList.add('visible');
}

function syntaxHighlightJSON(line) {
  // Highlight JSON keys: "key":
  line = line.replace(/^(\s*)(&quot;[^&]*?&quot;)(\s*:)/g, '$1<span class="syn-key">$2</span>$3');
  // Highlight string values (after colon)
  line = line.replace(/(:\s*)(&quot;[^&]*?&quot;)/g, '$1<span class="syn-str">$2</span>');
  // Highlight standalone strings in arrays
  line = line.replace(/([\[,]\s*)(&quot;[^&]*?&quot;)/g, '$1<span class="syn-str">$2</span>');
  // Highlight numbers
  line = line.replace(/(:\s*)(-?\d+\.?\d*)/g, '$1<span class="syn-num">$2</span>');
  // Highlight booleans and null
  line = line.replace(/(:\s*)(true|false|null)/g, '$1<span class="syn-bool">$2</span>');
  return line;
}

function closeMetaFullscreen() {
  metaFS.classList.remove('visible');
}

metaFS.querySelector('.meta-fs-close').addEventListener('click', closeMetaFullscreen);
metaFS.addEventListener('click', function(e) {
  if (e.target === metaFS) closeMetaFullscreen();
});

</script>
</body>
</html>
